<html>
  <head>
    <title>weird prism</title>
    <meta charset="utf-8">
  </head>
  <body>
    <canvas>
    </canvas>
    <style>
      body {
        margin: 0;
      }
    </style>
    <script>
      const canvas = document.querySelector('canvas');
      const ctx = canvas.getContext('2d');
      const unitLength = 150;
      let DEBUG = true;

      const state = {
        prismCenter: [0, 0],
        rayOrigin: [-1, 1],
        rays: [{
          color: "#e6261f"
        }, {
          color: "#eb7532"
        }, {
          color: "#f7d038"
        }, {
          color: "#a3e048"
        }, {
          color: "#49da9a"
        }, {
          color: "#34bbe6"
        }, {
          color: "#4355db"
        }, {
          color: "#d23be7"
        }].map(r => ({ ...r, seed: Math.random() }))
      };

      const devicePixelRatio = window.devicePixelRatio || 1;
      function scale(value) {
        return value * unitLength * devicePixelRatio;
      }
      // Put the origin of the coordinates system on the left of the of canvas
      function x(value) {
        return canvas.width / 3 + scale(value);
      }
      function y(value) {
        return canvas.height / 2 + scale(value);
      }
      function invertX(xValue) {
        const value = (xValue - canvas.width / devicePixelRatio / 3) / unitLength;
        console.assert(Math.abs(xValue * devicePixelRatio - x(value)) < 0.001);
        return value;
      }
      function invertY(yValue) {
        const value = (yValue - canvas.height / devicePixelRatio / 2) / unitLength;
        console.assert(Math.abs(yValue * devicePixelRatio - y(value)) < 0.001);
        return value;
      }

      function adjustCanvasSize() {
        const width = document.body.clientWidth;
        const height = document.body.clientHeight;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        canvas.width = width * devicePixelRatio;
        canvas.height = height * devicePixelRatio;
      }

      function handleCanvasClick(event) {
        console.log(event);
        const rayOrigin = [invertX(event.x), invertY(event.y)];
        state.rayOrigin = rayOrigin;
        draw();
      }
      function handleCanvasMousedown(event) {
        state.dragging = true;
      }
      function handleCanvasMouseup(event) {
        state.dragging = false;
      }
      function handleCanvasMousemove(event) {
        if (!state.dragging) return;

        const rayOrigin = [invertX(event.x), invertY(event.y)];

        state.rayOrigin = rayOrigin;
        draw();
      }

      function drawPrism() {
        const prismCenter = state.prismCenter;
        const prismEdge = 1;
        const prismHeight = prismEdge * Math.sqrt(3) / 2;

        // Draw prism center
        ctx.save();
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x(prismCenter[0]), y(prismCenter[1]), 3, 0, 2 * Math.PI);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();

        // Draw prism triangle
        ctx.save();
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x(prismCenter[0]), y(prismCenter[1] - prismHeight * 2 / 3));
        ctx.lineTo(x(prismCenter[0] + prismEdge / 2), y(prismCenter[1] + prismHeight / 3));
        ctx.lineTo(x(prismCenter[0] - prismEdge / 2), y(prismCenter[1] + prismHeight / 3));
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }

      function drawRay() {
        const prismCenter = state.prismCenter;
        const rayOrigin = state.rayOrigin;
        const farRayOrigin = [
          (rayOrigin[0] - prismCenter[0]) * 30,
          (rayOrigin[1] - prismCenter[1]) * 30,
        ];

        ctx.save();
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x(prismCenter[0]), y(prismCenter[1]));
        ctx.lineTo(x(farRayOrigin[0]), y(farRayOrigin[1]));
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }

      function drawRays() {
        const prismCenter = state.prismCenter;
        const rayOrigin = state.rayOrigin;
        const rayAngle = Math.atan2((rayOrigin[1] - prismCenter[1]), (prismCenter[0] - rayOrigin[0]));
        const raysAngle = rayAngle / -2;
        console.log("ANGLES", rayAngle, raysAngle)

        const steps = 500;
        const stepLength = 0.015;

        function calculateRayPoints(ray, angle) {
          const points = [];

          for(let step = 0; step < steps; step+=1) {
            const deviation = ray.seed * 0.5;
            const rotationBasis = ((angle - raysAngle) / raysAngle) * 2 * Math.PI + step * stepLength;
            const rotation = Math.sin(rotationBasis) / 5;
            // const nextY = (Math.pow(1.065, 40 * Math.log(1 + step * stepLength)) - 1) * deviation * rotation;
            const nextY = (Math.pow(1.05, 40 * Math.log(1 + step * stepLength)) - 1) * deviation * rotation;
            // const nextY = step * stepLength * Math.tan(angle);
            const nextX = step * stepLength;
            const nextThickness = step * stepLength * 0.05;
            const nextZ = Math.cos(rotationBasis);
            points.push({ x: nextX, y: nextY, z: nextZ, thickness: nextThickness });
          }
          return points;
        }

        const dispersion = Math.PI / 24 / (Math.abs(raysAngle) + 1);
        const raysWithPoints = state.rays.map((ray, idx) => {
          const rayPoints = calculateRayPoints(ray, raysAngle + -1 * ((state.rays.length + 1) / 2 - idx) * dispersion);
          return [ray, rayPoints];
        });


        // Draw rays!
        ctx.save();
        ctx.translate(x(prismCenter[0]), y(prismCenter[1]));
        ctx.rotate(raysAngle) // Rotate based on "main" axis
        ctx.translate(-x(prismCenter[0]), -y(prismCenter[1]));

        // Draw rays sequentially
        raysWithPoints.forEach(([ray, points]) => {
          console.log("DRAWING RAY", ray.color);
          ctx.beginPath();
          ctx.moveTo(x(0), y(0));
          points.forEach((point, step) => {
            const nextY = y(point.y);
            const nextX = x(point.x);
            if (DEBUG) {
              ctx.arc(nextX, nextY, scale(point.thickness), 0, 2 * Math.PI);
            }
            ctx.lineTo(nextX, nextY);
          });
          points.slice().reverse().forEach(point => {
            ctx.lineTo(x(point.x), y(point.y));
          });
          ctx.strokeStyle = ray.color;
          ctx.fillStyle = ray.color;
          ctx.lineWidth = 3;
          ctx.stroke();
          ctx.fill();
          ctx.closePath();
        });

        // Draw rays in parallel
        const pointsCount = raysWithPoints[0][1].length;
        /*
        console.log(raysWithPoints);
        for (let step = 0; step < pointsCount; step += 1) {
          const raysWithPointsAtStep = raysWithPoints.map(([ray, points]) => [ray, points[step]]);
          raysWithPointsAtStep.sort(([_ray1, point1], [_ray2, point2]) => point2.z - point1.z);

          raysWithPointsAtStep.forEach(([ray, point]) => {
            // console.log("POINT", point, "RAY", ray);
            ctx.beginPath();
            const nextY = y(point.y);
            const nextX = x(point.x);
            ctx.arc(nextX, nextY, scale(point.thickness), 0, 2 * Math.PI);
            ctx.strokeStyle = ray.color;
            ctx.fillStyle = ray.color;
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fill();
            ctx.closePath();
          });
        }
        */
        ctx.restore();
      }

      function drawRayOrigin() {
        if (!DEBUG) return;

        const draggedPosition = state.rayOrigin;

        // Draw dragging point
        ctx.save();
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x(draggedPosition[0]), y(draggedPosition[1]), 3, 0, 2 * Math.PI);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }

      function draw() {
        if(DEBUG) {
          console.log("DRAWING", state);
        }
        ctx.closePath();
        // Clear canvas
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();

        drawPrism();
        drawRayOrigin();
        drawRay();
        drawRays();
      }

      function distance2d([x1, y1], [x2, y2]) {
        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
      }

      adjustCanvasSize();
      window.addEventListener('resize', () => adjustCanvasSize());
      window.addEventListener('resize', () => draw());
      canvas.addEventListener('click', handleCanvasClick);
      canvas.addEventListener('mousedown', handleCanvasMousedown);
      canvas.addEventListener('mouseup', handleCanvasMouseup);
      canvas.addEventListener('mousemove', handleCanvasMousemove);
      draw();
    </script>
  </body>
</html>
